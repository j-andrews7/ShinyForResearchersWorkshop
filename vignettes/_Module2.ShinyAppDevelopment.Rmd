---
title: "Module 2 - Shiny App Development"
author: 
- name: "Jared Andrews"
  email: jared.andrews@stjude.org
  affiliation: St. Jude Children's Research Hospital, Memphis, TN
date: "May 14th, 2023"
output: 
  html_document:
    code_folding: show
    toc: true
    toc_depth: 5
    toc_float: true	 
runtime: shiny
vignette: >
  %\VignetteIndexEntry{Shiny App Development}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{css, echo=FALSE}
// This is a CSS code chunk to make the page wider, as the default width is annoyingly narrow.
body {
  max-width: 1400px !important;
}
div.main-container {
  max-width: 1400px !important;
  width: 1400px !important;
  margin-left: auto !important;
  margin-right: auto !important;
}
.toc-content {
  padding-right: 0px;
  padding-left: 0px;
  margin-left: 300px;
  max-width: 1100px !important;
  width: 1100px !important;
}
```

```{r, include=FALSE}
knitr::opts_chunk$set(
  fig.path = "man/figures/"
)
```

## Overview

**St. Jude members may view [an interactive form of this document here](https://svlpbakerlab01.stjude.org/ShinyWorkshopModule2/).** 
Must be connected to the St. Jude network to view.

There's a lot that can be done with Shiny, and it's easy to get overwhelmed at first.

In this module, we will: 
- show why designing your app before you start coding is important, 
- demonstrate a few different layout options provided by Shiny, 
- provide examples of how to introduce interactivity into your app,
- and work through a more complex example of a Shiny app to cement the concepts we've learned.

## Principles of App Design

Before starting to code your Shiny app, it's important to sketch out the UI and think about how your data will be used. 
This allows you to design the app in a way that best meets your users' needs.

For instance, if we're designing a Shiny app to explore a given dataset, we might want to allow users to:

- Select which variables to plot on the x and y axes.
- Choose the type of plot (scatterplot, histogram, etc.).
- Color the points by a given variable.

Given these needs, we can sketch out a UI that includes select inputs for the x and y variables, 
the plot type, and the color, as well as a main panel for displaying the plot.

Or we can ask chatGPT to do it for us:

<img align="center" src="man/figures/MockUI.PNG" alt="chatGPT-generated mock UI for this app" width="500" />

### This Ain't Art Class, Can't We Get to the Code Already?

We could, but **if your app layout/behavior sucks, nobody will use it.**

- If it's unwieldy, people will almost immediately get frustrated and not bother with it.

- If it's ugly, people will think it's unprofessional and not bother with it.

- If it's confusing, people will feel dumb (or think you're dumb and built it wrong) and not bother with it.

- If it's slow, people will get bored and not bother with it.

Learn from me. 
I've made all of these mistakes.
These are the realities of software development, especially in science.

Without planning, you end up creating more work for yourself down the line in the form of unnecessary rewrites, buggy interactions, and confusing layouts.

Here are some of the bad things that *will eventually happen* if you don't get in the habit of planning your applications out:

- **Adding Features Without Prior Planning**: Let's say you initially design your app to display a scatter plot of two variables from a given dataset, 
and you later decide to add the option for users to display a histogram of a single variable. 
Because these two plot types require different inputs (a single variable for the histogram vs. two variables for the scatter plot), 
you may have to substantially rewrite your UI and server code to handle this new functionality. 
If you had planned for this feature from the start, you could have designed your UI and server in a way that accommodates both plot types, saving you time and effort.

- **Failure to Consider Data Structure**: Suppose your Shiny app is designed around a specific dataset, which is well-structured and doesn't contain any missing values. 
If you then decide to use a different dataset that contains missing values or a different structure, you may have to rewrite parts of your app to handle these differences. 
Proper planning involves considering the structure and peculiarities of your data, which can help you write more robust code that can handle different types of data.

- **Not Anticipating User Inputs**: It's important to design your Shiny app in a way that anticipates a wide range of user inputs. 
For example, if your app includes a text input where users can enter a title for a plot, you might not initially consider that users 
could enter very long titles that disrupt the layout of your app. If you don't plan for this possibility, 
you might have to go back and add code to handle it, such as by truncating long titles or adjusting the layout to accommodate them.

- **Complex UI without Logical Layout**: Without proper planning, you might end up with a UI that has a variety of widgets 
(sliders, checkboxes, dropdowns) without a logical layout, which can make the app difficult for users to navigate. 
You might then have to spend extra time rearranging and reorganizing your UI. 
However, if you had sketched out your UI beforehand and considered how users will interact with your app, 
you could have designed a logical, user-friendly layout from the start.


### Questions to Ask Before You Start

So before you start, ask yourself (and potential users!) a few questions:

- Who will be using the app?
- What will they be using it for?
- What data will the app be expected to handle?
- What are the most important features of the data?
- What are the most important features of the app?
- What additions or changes might be made to the app in the future?

Slow is smooth, but smooth becomes fast. Or move fast and break things. There's some sort of saying for this.

Whatever, just plan your app. 

### An Example of Poor Planning

Suppose we have a simple Shiny app that was originally designed to display a scatter plot for the iris dataset. 
The UI contains two `selectInput` widgets for users to select the variables for the x and y axes of the scatter plot.

```{r}
library(shiny)
library(ggplot2)

# Define UI
ui <- fluidPage(
    titlePanel("Simple Scatter Plot"),
    sidebarLayout(
        sidebarPanel(
            selectInput("xvar", "X Variable", names(iris)[1:4]), # Limit to the numeric columns only.
            selectInput("yvar", "Y Variable", names(iris)[1:4])
        ),
        mainPanel(
            plotOutput("scatterPlot")
        )
    )
)

# Define Server
server <- function(input, output) {
    output$scatterPlot <- renderPlot({
        ggplot(iris, aes(x = .data[[input$xvar]], y = .data[[input$yvar]])) +
            geom_point()
    })
}

# Run the Shiny app
shinyApp(ui = ui, server = server, options = list(height = 550))
```

Now, let's say we want to add a feature for users to display a histogram of a single variable. 
We add a `radioButton` widget for users to select the plot type and a new `selectInput` for the histogram variable. 
We also modify the server function to render the plot based on the selected plot type.

```{r}
ui <- fluidPage(
    titlePanel("Simple Scatter Plot"),
    sidebarLayout(
        sidebarPanel(
            radioButtons("plotType", "Plot Type", c("Scatter Plot", "Histogram")),
            selectInput("xvar", "X Variable", names(iris)[1:4]), # Limit to the numeric columns only.
            selectInput("yvar", "Y Variable", names(iris)[1:4]),
            selectInput("histVar", "Histogram Variable", names(iris)[1:4])
        ),
        mainPanel(
            plotOutput("plot")
        )
    )
)

server <- function(input, output) {
    output$plot <- renderPlot({
        if (input$plotType == "Scatter Plot") {
            ggplot(iris, aes(x = .data[[input$xvar]], y = .data[[input$yvar]])) +
                geom_point()
        } else {
            ggplot(iris, aes(x = .data[[input$histVar]])) +
                geom_histogram(binwidth = 0.5)
        }
    })
}

shinyApp(ui = ui, server = server, options = list(height = 550))
```

While this code will work, it's not very clean or efficient. 
The UI has become cluttered with inputs that don't apply to all plot types, 
and the server function contains an if-else statement that will become even more unwieldy if we decide to add more plot types in the future.

If we had planned for the possibility of multiple plot types from the start, 
we could have designed the UI and server in a way that more easily accommodates this feature, 
such as by grouping the inputs for each plot type and using reactive expressions to generate the plots.

### The Redesign

Can you think of a better way to design the UI and server for this app? 
Take a minute to think about it before expanding the solution below.

<details>
  <summary>A Solution</summary>

One way would to use `conditionalPanel()` in the UI, which is a way to show/hide UI elements based on a condition (like which plot type is selected).

```{r}
ui <- fluidPage(
    titlePanel("Interactive Plots"),
    sidebarLayout(
        sidebarPanel(
            radioButtons("plotType", "Plot Type", c("Scatter Plot", "Histogram")),
            conditionalPanel(
                condition = "input.plotType == 'Scatter Plot'",
                selectInput("xvar", "X Variable", names(iris)[1:4]),
                selectInput("yvar", "Y Variable", names(iris)[1:4])
            ),
            conditionalPanel(
                condition = "input.plotType == 'Histogram'",
                selectInput("histVar", "Histogram Variable", names(iris)[1:4])
            )
        ),
        mainPanel(
            plotOutput("plot")
        )
    )
)

server <- function(input, output) {
    scatterPlot <- reactive({
        ggplot(iris, aes(x = .data[[input$xvar]], y = .data[[input$yvar]])) +
            geom_point()
    })

    histogram <- reactive({
        ggplot(iris, aes(x = .data[[input$histVar]])) +
            geom_histogram(binwidth = 0.5)
    })

    output$plot <- renderPlot({
        if (input$plotType == "Scatter Plot") {
            scatterPlot()
        } else {
            histogram()
        }
    })
}

shinyApp(ui = ui, server = server, options = list(height = 550))
```

Now, the UI only displays the relevant inputs for the selected plot type, making it cleaner and easier for users to interact with. 
The server uses reactive expressions to generate the plots, making the code more modular and easier to maintain. 
If we decide to add more plot types in the future, we can easily add more `conditionalPanel()`s in the UI and more reactive expressions in the server.

</details>

## Picking a Layout

Shiny allows for almost any layout you can imagine, but there are a few common layouts that you'll see in most Shiny apps.
