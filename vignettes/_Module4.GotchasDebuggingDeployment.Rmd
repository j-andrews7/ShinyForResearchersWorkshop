---
title: "Module 4 - Common Gotchas, Debugging Shiny, and Deployment Options"
author: 
- name: "Jared Andrews"
  email: jared.andrews@stjude.org
  affiliation: St. Jude Children's Research Hospital, Memphis, TN
date: "May 12th, 2023"
output: 
  html_document:
    code_folding: show
    toc: true
    toc_depth: 5
    toc_float: true	 
runtime: shiny
vignette: >
  %\VignetteIndexEntry{Common Gotchas, Debugging Shiny, and Deployment Options}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{css, echo=FALSE}
// This is a CSS code chunk to make the page wider, as the default width is annoyingly narrow.
body {
  max-width: 1850px !important;
}
div.main-container {
  max-width: 1850px !important;
  width: 1850px !important;
  margin-left: auto !important;
  margin-right: auto !important;
}
.toc-content {
  padding-right: 0px;
  padding-left: 0px;
  margin-left: 300px;
  max-width: 1550px !important;
  width: 1550px !important;
}
```

**St. Jude members may view [an interactive form of this document here](https://svlpbakerlab01.stjude.org/ShinyWorkshopModule4/).** 
Must be connected to the St. Jude network to view.

## Common Gotchas and Debugging Challenges

Debugging, the process of finding and fixing bugs, is a critical skill when working with Shiny apps, just like with any other programming. 

There are many "gotchas" that beginner Shiny developers can run into, and these are typically more difficult to troubleshoot than typical R code for a few reasons.

These debugging challenges stem from:

- **Reactivity:** Shiny operates on a reactive programming model, which can be quite different from the standard procedural programming model common in R. 
In reactive programming, outputs are automatically updated based on changes to inputs. 
This can make it harder to reason about the order in which different parts of your code are executed, especially for beginners.

- **Asynchronous operations:** Shiny apps often involve asynchronous operations, such as user input or data loading. 
These operations can occur at any time and in any order, which can make bugs harder to reproduce and track down.

- **Reactive context:** Reactive expressions in Shiny apps can only be evaluated in a reactive context. 
Trying to access reactive values outside of this context can lead to errors. 
This restriction can make it challenging to debug Shiny apps using traditional methods, like print statements or the browser console.

- **Multiple environments:** Shiny applications have multiple environments (user-interface environment, server environment) where the code runs. 
This can lead to issues if you're not careful about where variables are defined and accessed.

- **Concurrency issues:** Shiny apps can be accessed by multiple users at the same time, and each user has their own session. 
This can lead to concurrency issues, which can be very difficult to debug. 
For example, a bug might only occur when two users interact with the app in a certain way at the same time.

- **Deployment-related issues:** Problems may arise when deploying Shiny apps that were not present during local development. 
These can be due to differences in the environments, such as different R versions available or missing system dependencies on the host.

## Debugging Shiny Apps

Here are a few techniques you can use to debug your Shiny apps:

- **The `browser()` function:** This function pauses execution of your app and lets you interactively run and inspect code. 
You can step through your code line by line and examine the current state of variables and reactives. 

For example:
```{r, eval = FALSE}
ui <- fluidPage(
    titlePanel("Debugging Shiny Apps"),
    sidebarLayout(
        sidebarPanel(
            numericInput("num", "Enter a number", value = 1)
        ),
        mainPanel(
            textOutput("result")
        )
    )
)

server <- function(input, output) {
    output$result <- renderText({
        browser()
        x <- 1 / as.numeric(input$num)
        paste("The reciprocal is", x)
    })
}

shinyApp(ui, server)
```

When the `browser()` line is hit, you'll be able to step through the code and see the value of each variable at each step.

Consider this your bread and butter for debugging Shiny apps and R code in general.

- **Using the react log:** This method uses the `reactlog` package to log reactive events in your app.
This can be very helpful to see when and why your reactive expressions are firing.

To see how it works, launch our simple app and change the input value a few times.
```{r, eval = FALSE}
library(reactlog)
reactlog_enable() # This turns on reactive logging for Shiny apps in the R session.

server <- function(input, output) {
    output$result <- renderText({
        x <- 1 / as.numeric(input$num)
        paste("The reciprocal is", x)
    })
}

shinyApp(ui, server)
```

Now open the react log.

```{r, eval = FALSE}
shiny::reactlogShow()
```

This is useful when you're unsure of when and why your reactives are firing.

- **The `reactiveConsole()` function:** This one isn't necessarily a debugging tool, but it's useful for playing around with reactives in the console.
This function allows you to interactively run code that involves reactive values or expressions. 
Normally, you can't do this because reactives only work within the correct reactive context. 
But when you call `reactiveConsole(TRUE)`, you can run this code directly from the console.

**This is an experimental feature currently, but it's useful for playing around with reactives in the console.**

For example:

```{r, eval = FALSE}
reactiveConsole(TRUE)

x <- reactiveVal(10)
y <- observe({
    message("The value of x is ", x())
})
x(20)
x(30)

reactiveConsole(FALSE)
```

This is useful when you want to experiment with reactives to see how they interact.

Remember, debugging is a skill that takes practice to develop, and these tools will help you identify and fix issues in your Shiny apps more easily.

### An Exercise in Debugging

Here's a common "gotcha" scenario involving reactivity and debugging in R Shiny.

Consider the following simple Shiny app:

```{r}
ui <- fluidPage(
    textInput("inputText", "Enter some text:"),
    actionButton("goButton", "Go"),
    textOutput("outputText")
)

server <- function(input, output) {
    observeEvent(input$goButton, {
        output$outputText <- renderText({
            paste("You entered:", input$inputText)
        })
    })
}

shinyApp(ui = ui, server = server)
```

In this app, the user is supposed to enter some text, then click the "Go" button to display the entered text. 
However, when you run this app and try to use it, you'll find that the "Go" button doesn't seem to do anything beyond the first press. 
The output text doesn't update when you click the button, but when you input the number.

Take a close look at the code. 
Have any ideas about what's going on?

#### Using `browser()` to Debug

Let's try using our newfound friend, the `browser` function, to see if we can figure out what's going on.

First, we have to add the `browser()` function to our code.
Execution will pause at whatever point we place it, and we'll be able to explore the environment or step through the code line by line.

Take a second to think about where it makes the most sense to place the `browser()` function in this app.

You can use as many browser calls as you'd like - execution will pause at each, but usually you'll only need one or two near where the problem is occurring.

```{r, eval = FALSE}
ui <- fluidPage(
    textInput("inputText", "Enter some text:"),
    actionButton("goButton", "Go"),
    textOutput("outputText")
)

server <- function(input, output) {
    observeEvent(input$goButton, {
        output$outputText <- renderText({
            browser() # Add browser() call here
            paste("You entered:", input$inputText)
        })
    })
}

shinyApp(ui = ui, server = server)
```

When you run this app, enter some text, and click the "Go" button, the app will pause and you'll be put into browser mode. 
You can now inspect the environment at this point in the execution. 
For example, you could check the value of `input$inputText`.

Click "Continue" to resume execution, then change the input values. 
This will result in `browser` being called again.

In this case, the `browser()` function can help you understand that `renderText` is being recomputed even when the button isn't pressed. 
In general, `browser()` is a great tool for understanding the flow of a Shiny app and figuring out where things are going wrong. 
It's especially useful in more complex apps where the control flow and reactivity can be difficult to follow.

#### The Issue

The mistake here is a misunderstanding about how reactivity works in Shiny. 

`observeEvent` depends on `input$goButton`, but the expression passed to it is not isolated. 

That means that if it uses or depends on reactive values, it will be re-executed whenever those values change, regardless of whether the event has occurred.
The `renderText` function includes `input$inputText`, which is a reactive value, so `renderText` will be re-executed whenever the value of `input$inputText` changes.

There are a few ways to fix this:

1. Use `isolate()` to prevent `renderText` from being re-executed when `input$inputText` changes.

`isolate` is a function that prevents reactive values from triggering recomputation of a reactive expression. 
 It is very useful for situations like this where you want output to be updated only when a certain event occurs. 

<details>
  <summary>Solution 1</summary>

```{r}
ui <- fluidPage(
    textInput("inputText", "Enter some text:"),
    actionButton("goButton", "Go"),
    textOutput("outputText")
)

server <- function(input, output) {
    observeEvent(input$goButton, {
        output$outputText <- renderText({
            # Note wrapping of input$inputText in isolate()
            paste("You entered:", isolate(input$inputText))
        })
    })
}

shinyApp(ui = ui, server = server)
```

</details>

2. Get rid of the `observeEvent` and check the value of `input$goButton` inside of `renderText`, again coupled with `isolate`.
  
<details>
  <summary>Solution 1</summary>

```{r}
ui <- fluidPage(
    textInput("inputText", "Enter some text:"),
    actionButton("goButton", "Go"),
    textOutput("outputText")
)

server <- function(input, output) {
    output$outputText <- renderText({
        # Action buttons have a counter that increments on click.
        # This will prevent the text from updating until the button is clicked.
        if (input$goButton == 0) {
            return(NULL)
        }
        paste("You entered:", isolate(input$inputText))
    })
}

shinyApp(ui = ui, server = server)
```

</details>

The second solution is a more common pattern for using action buttons than the first solution. 
It's easier to follow and doesn't require an additional reactive expression in the form of the `observeEvent` call.

The `isolate` function is used to prevent `input$inputText` from triggering recomputation on its own, so the text will only update when the button is clicked.

This example illustrates a common misunderstanding about Shiny's reactivity model, and also demonstrates the kind of thinking required to debug a Shiny app. 
Debugging in Shiny can be challenging because the code execution is event-driven and asynchronous, which is quite different from the usual top-to-bottom flow of an R script.

## Deployment Options

After you've built your Shiny application, the next step is to share it with the world. Or your lab.
There are several ways to do this, ranging from simple and free solutions for small apps, 
to more complex and robust methods for large-scale applications. 

In this section, we'll cover two popular deployment options: shinyapps.io and Posit (formerly RStudio) Connect.

### Shinyapps.io

Shinyapps.io is a service provided by RStudio for hosting Shiny applications. 
It's an easy way to publish your applications to the web without needing to manage a server.

#### Key features:
- **Simple Deployment:** You can publish your apps directly from your RStudio IDE with a few clicks.

- **Scalability:** Shinyapps.io can automatically manage the server resources for your app, scaling it up and down as needed based on traffic.

- **Authentication and User Management:** With shinyapps.io, you can control who can access your applications. It also supports Google Authentication and GitHub.

- **Analytics:** Shinyapps.io provides usage statistics for your applications, so you can see how many people are using it, when, and from where.

#### Limitations:
- The free tier of shinyapps.io has limitations on the number of active hours your apps can have in a month, 
the number of applications you can deploy, and the resources each can use (e.g. 4GB memory) max.

While shinyapps.io is great for small to medium-sized applications, for large-scale enterprise applications, you might need more control over your server environment.

### Posit Connect

Posit Connect is a more commerical, professional publishing platform. 
It is designed to help you share Shiny applications, R Markdown reports, Plumber APIs, data Pins, and more with your colleagues and organization.

#### Key features:
- **Flexible Deployment:** You can deploy your apps on your own servers, giving you more control over the environment.

- **Security and Access Control:** RStudio Connect offers robust security features, including integration with many enterprise authentication systems. 
You can control who can access your applications at a very granular level.

- **Schedule Reports:** One of the most powerful features of RStudio Connect is the ability to schedule R Markdown reports and have them emailed to a list of recipients.

- **Manage Multiple R Versions:** RStudio Connect supports multiple versions of R concurrently. 
This can be crucial for reproducibility in team settings.

#### Limitations:
- RStudio Connect is a commercial product, and it comes with a hefty cost.
Fortunately, St. Jude has a liecense, so we don't have to worry about said cost.

- Setting up RStudio Connect requires more technical expertise than using shinyapps.io. 
You'll need to install and manage it on your own server.
However, once it's set up, it's very easy to deploy applications from RStudio.
You can put in a serviceNow request to have a VM spun up and Posit Connect installed on it.

- Making apps publically available is a bit more complicated than shinyapps.io, and St. Jude IT/legal has concerns if data is to be uploaded to the server.
